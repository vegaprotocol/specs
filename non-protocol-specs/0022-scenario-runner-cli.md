Feature name: scenario-runner-cli 

# Summary

**Scenario runner** is a broad term describing a tool or set of tools for exploratory testing and analysis of the Vega network. It's primary purpose is to support the stakeholders in reviewing the mechanics of the protocol and results generated by it.
It may evolve into a tool allowing market simulation, backtesting of trading strategies or automated comparison of results obtained with the **trading protocol** running with different sets of configurations.  

In this spec we are focusing on the first iteration of the `scenario-runner-cli`: a command line interface exposing the core functionality which allows the user to interact with the protocol in an automated and reproducible way. The inputs are handled by `trading-core` running without the consensus layer to assure maximum performance.

# Acceptance Criteria

- [ ] --help command is available.
- [ ] `config` file exposing default values (e.g. protocol time advancement per submitted instruction) exists and can be modified by the user.
- [ ] Example `InstructionsFile` in `JSON` format is available.
- [ ] `SubmitInstructions` function is available and all the write instructions defined in `trading` in [`trading.proto`](https://github.com/vegaprotocol/api/blob/develop/proto/api/trading.proto) can be submitted to it.
- [ ] Protocol time is advanced by a fixed amount after each instruction is submitted. User has the option to set it to 0. User has the option to explicitly specify change in protocol time with a dedicated instruction.
- [ ] `ExtractData` function is available and can output results of any synchronous calls defined in `trading_data` in [`trading.proto`](https://github.com/vegaprotocol/api/blob/develop/proto/api/trading.proto). The output file should be in the `JSON` format.
- [ ] The input `JSON` file contains metadata defining the version of the schema.
- [ ] The output file (`DataFile`) contains metadata with the information on the version of `trading-core` used to generate it.
- [ ] `DataFile` contains **protocol metadata** defined in [commands](#commands) subsection.

# Guide-level explanation

`scenario-runner-cli` is a command-line tool used for interacting with the instance of a Vega network. It can submit all the trading and collateral management-related instructions defined in the protocol. It interacts directly with the `trading-core` node running without the consensus layer for maximum performance and throughput.

The main functionality is:

- `SubmitInstructions`: Reads a set of instructions from the `InstructionsFile` and submits them to the `trading-core`.
- `ExtractData`: Extracts the trading data from the node subject to additional, user-defined filtering and outputs it as a `DataFile`.

# Reference-level explanation

`scenario-runner-cli` is a binary generated by `trading-core`. That allows easy access to the internal logic of `trading-core` and assures consistency and interoperability with it as it evolves. The user interacts with it via the command line.  The `--help` command and example `InstructionsFiles` are available.

## Commands

- `SubmitInstructions` - takes in a path to the `InstructionsFile` in `JSON` format.
  - Supports all the instructions defined in `trading` in [`trading.proto`](https://github.com/vegaprotocol/api/blob/develop/proto/api/trading.proto).
  - By default each instruction advances the protocol time by a fixed amount (e.g. 1ms) controllable via the `config` file.
  - Dedicated instruction exists which allows explicit control of the flow of time.
- `ExtractData` - takes a path where the `DataFile` should be saved:
  - By default `DataFile` includes **protocol metadata** with:
    - Number of instructions processed.
    - Number of omitted instructions and a reference to `log` outlining the details of those instructions.
    - Time taken to process all the instructions.
    - Number of trades generated.
    - State of the order book after last instruction.
  - By default results of the synchronous calls (excluding streams) defined in `trading_data` in [`trading.proto`](https://github.com/vegaprotocol/api/blob/develop/proto/api/trading.proto)
    are included in the `DataFile`.
  - Optional: user can fine-tune the contents of a `DataFile` with `scenario-runner-cli` specific commands to filter the results as needed before writing-out the file - **nice to have**

## Data formats

- `InstructionsFile` - supported data formats:
  - JSON
- `DataFile` needs to support further querying and slicing of data using generally available languages and tools. Supported formats:
  - JSON
  - Optionally: SQLite - **nice to have**

# Test cases

- Output is the same irrespective of using `1` file with `n` instructions or `n` files with `1` instruction.
- Empty `InstructionsFile` flows through the system without errors, warning is recorded.
- Submitting a matching buy and sell order results in a trade being generated.
- A large number of simple instructions (~ million) can be processed in a reasonable amount of time (<10mins)
- When a failure condition occurs all the resources are released and no partial outputs are given.

# Appendix

This section contains additional information that isn't immediately applicable to the current version of `scenario-runner-cli`, but relates to its' future iterations and the broader "scenario runner" concept described in the [summary](#summary).

## Possible future extensions

This sub-section lists future additions that may be required. It's meant to allow collaboration on shape of both the `scenario-runner-cli` and the possible broader ecosystem of tools spanning the **scenario runner** concept.

The currently identified additions that will likely be useful going forward are (please note ordering doesn't imply relative importance, that should be decided when these are scoped and included in a different spec):

- Support filtering of outputs on the fly to aid performance and allow more control of the size of an output file.
- Expose additional, internal/intermediate data not defined in `trading_data` in [`trading.proto`](https://github.com/vegaprotocol/api/blob/develop/proto/api/trading.proto)
- Support submitting instructions to an instance of the network running with the consensus layer. This will support only the subset of instructions available in scenario runner that overlap with the [`trading.proto`](https://github.com/vegaprotocol/api/blob/develop/proto/api/trading.proto).
- Add bots - the option to add trading logic which works algorithmically as opposed to reading a static set of instructions.
- "Diff" network states: compare another pre-saved state of network with the one generated by a given scenario (this is for general regression testing / continuous integration.)
- Extend set of available commands to allow modelling more complex network interactions within the network (multi-node configuration, node failures, nodes joining etc.)
- Include a backtesting framework to facilitate evaluation of investment strategies.
- Add a UI.
  - Adhere to conventions followed in the `client` repo so that the scenario runner UI can be used both standalone and as a component withing the main UI.

## Things to consider

- Versioning
  - It's quite likely that we will end up adding more node instructions and/or modify the existing ones.
  - By that time we may already have a large collection of scenario runner `StateFile`s
  - Need to build in backwards compatibility or a way of updating them to the latest standard as considerable time and effort might have been put into generating some of them and the process might not be easy to reproduce (scrips that get lost or become stale, manual fine-tuning of certain values etc.)
- Referencing data related to entities changing over time
  - Some data will change throughout the life-cycle of the entities it relates to - e.g. first version of an order then updates when trades occur.
    - Need to reference those entities in a consistent way and capture data relating to all the states (e.g. pending order, matched order & trade)
    - We may want to include additional filtering options so that user can fine-tune the amount of data included in the output file to balance visibility of intermediate state with readability of output file for different use cases.
